# 浏览器缓存策略: 强缓存和协商缓存：
	浏览器进行资源请求时，会判断响应头（响应头携带cache-control/expires）是否命中强缓存，
  命中，直接从本地读取缓存，不会向服务器发送请求.
	当强缓存没有命中，则会发送请求到服务端，判断协商缓存是否命中，
  命中服务器将请求返回，不会返回资源，告诉浏览器从本地读取缓存。
	如果不命中，服务器直接返回资源；
  **区别**: 强缓存命中，不会请求服务器，直接请求缓存；
		        协商缓存命中，会请求服务器，不会返回资源，然后从浏览器读取缓存。

# from memory cache和from disk cache
* from memory cache: 
  资源是从内存中拿到的，之前已经加载过该资源且缓存在内存中，
  不会请求服务器；当页面关闭，资源被内存释放掉，
  再次重新打开页面不会出现from memory cache
* from disk cache: 
* 资源是从磁盘中取出来的，之前加载过且被缓存了，
  不会请求服务器；资源不会随着该页面的关闭而释放，
  存在磁盘中的，下次打开还是from disk cache

# chrome采取的策略
200 from memory cache: 不请求网络资源，资源在内存中，一般是图片，脚本，字体
200 from disk cache: 不请求网络资源，在磁盘中，一般非脚本存放在内存中，css等
200 资源大小数值: 从服务器下载的最新资源
304 报文大小: 请求服务端发现资源没有更新，使用本地资源

# http状态码
* 状态码200: 资源是从服务端获取
* 状态码304: 该状态码是与服务端通信报文的大小，资源是从本地获取的

## 强缓存:
* 命中强缓存(memory cache)				
  * expires: new Date(Date.now() + 24 * 60 * 60 * 10000).toUTCString(), //24h后强缓存过期；
  * "cache-control": "max-age=5",  //5s内命中强缓存 HTTP 1.1；优先级高。
  * 请求资源，服务器**响应头**带上expires/cache-control判断是否命中强缓存
## 协商缓存
- 第一次发送请求:
  1. 设置强缓存
  2. 设置last-modified字段（文件最后修改日期）
  3. 强缓存失效，客户端再向服务器发请求
- 第二次发送请求
  4. 客户端（chrome）带上植入last-modified的If-Modified-Since字段向服务器发请求
  5. 服务器判断last-modified和If-Modified-Since是否相等；
     1. 相等则文件内容没有改动，走协商缓存，304状态码
        1. 设置"Cache-Control": "no-cache" （强缓存失效走协商缓存）
        2. 响应last-modified
     2. 不相等，文件修改过，重新发送请求
  6. Etag解决文件改动，但是实际文件内容未修改而没有走缓存的问题
     1. 根据文件hash判断文件内容是否改动

     2. 第二次请求带上植入Etag的if-none-match

# 状态码
304 Not Modified
如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。